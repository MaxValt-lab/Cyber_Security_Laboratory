import logging
import json
from datetime import datetime
from typing import List, Dict

logger = logging.getLogger("PTOAgent")
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

class PTOAgent:
    def __init__(
        self,
        smeta: List[Dict],
        dogovor: Dict,
        grafiki: List[Dict],
        akts_priemki: List[Dict],
        akts_sdachi: List[Dict],
        protocols: List[Dict],
        tech_tasks: List[Dict]
    ):
        self.smeta = smeta
        self.dogovor = dogovor
        self.grafiki = grafiki
        self.akts_priemki = akts_priemki
        self.akts_sdachi = akts_sdachi
        self.protocols = protocols
        self.tech_tasks = tech_tasks

        self.last_checks = {
            "budget": None,
            "schedule": None,
            "acceptance": None,
            "completion": None,
            "tech_tasks": None
        }

        self.validation_errors = []

    def validate_inputs(self):
        try:
            if not all('cost' in item for item in self.smeta):
                raise ValueError("–°–º–µ—Ç–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")
            if 'total_sum' not in self.dogovor:
                raise ValueError("–î–æ–≥–æ–≤–æ—Ä –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±—â—É—é —Å—É–º–º—É")
            for task in self.grafiki:
                if not all(key in task for key in ['name', 'planned']):
                    raise ValueError(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –≥—Ä–∞—Ñ–∏–∫–µ: {task}")
            for act in self.akts_priemki + self.akts_sdachi:
                if 'status' not in act:
                    raise ValueError("–ê–∫—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç–∞—Ç—É—Å")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(e)}")
            self.validation_errors.append(str(e))

    def check_budget(self) -> Dict:
        try:
            smeta_sum = sum(item['cost'] for item in self.smeta)
            contract_sum = self.dogovor.get('total_sum')
            status = "normal" if smeta_sum <= contract_sum else "exceeded"
            if status == "exceeded":
                logger.warning(f"üí∏ –ë—é–¥–∂–µ—Ç –ø—Ä–µ–≤—ã—à–µ–Ω: —Å–º–µ—Ç–∞ {smeta_sum}, –¥–æ–≥–æ–≤–æ—Ä {contract_sum}")
            else:
                logger.info("‚úÖ –ë—é–¥–∂–µ—Ç –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –Ω–æ—Ä–º—ã")
            result = {"status": status, "smeta": smeta_sum, "contract": contract_sum}
            self.last_checks["budget"] = result
            return result
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –±—é–¥–∂–µ—Ç–∞: {str(e)}")
            return {"error": str(e)}

    def check_schedule(self) -> List[Dict]:
        results = []
        for task in self.grafiki:
            try:
                planned = datetime.fromisoformat(task['planned'])
                actual_str = task.get('actual')
                actual = datetime.fromisoformat(actual_str) if actual_str else None
                if actual and actual > planned:
                    delay = (actual - planned).days
                    logger.warning(f"üìâ –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–æ –∑–∞–¥–∞—á–µ '{task['name']}': {delay} –¥–Ω–µ–π")
                    results.append({
                        "task": task['name'],
                        "status": "delayed",
                        "delay_days": delay,
                        "planned": planned.isoformat(),
                        "actual": actual.isoformat()
                    })
                else:
                    results.append({
                        "task": task['name'],
                        "status": "on_time",
                        "planned": planned.isoformat(),
                        "actual": actual.isoformat() if actual else None
                    })
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≥—Ä–∞—Ñ–∏–∫–∞: {str(e)}")
                results.append({
                    "task": task.get('name', 'unknown'),
                    "status": "error",
                    "error": str(e)
                })
        self.last_checks["schedule"] = results
        return results

    def verify_acceptance(self) -> List[Dict]:
        results = []
        for act in self.akts_priemki:
            try:
                if not act.get('approved'):
                    logger.warning(f"‚ö†Ô∏è –ê–∫—Ç –Ω–µ —É—Ç–≤–µ—Ä–∂–¥—ë–Ω: {act['stage']}")
                    results.append({"stage": act['stage'], "status": "not_approved"})
                else:
                    results.append({"stage": act['stage'], "status": "approved"})
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∞–∫—Ç–∞ –ø—Ä–∏—ë–º–∫–∏: {str(e)}")
                results.append({"stage": act.get('stage', 'unknown'), "error": str(e)})
        self.last_checks["acceptance"] = results
        return results

    def verify_completion(self) -> List[Dict]:
        results = []
        for act in self.akts_sdachi:
            try:
                status = act.get('status')
                if status != 'accepted':
                    logger.warning(f"‚ùå –û–±—ä–µ–∫—Ç –Ω–µ —Å–¥–∞–Ω: {act['stage']}")
                results.append({"stage": act['stage'], "status": status})
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∞–∫—Ç–∞ —Å–¥–∞—á–∏: {str(e)}")
                results.append({"stage": act.get('stage', 'unknown'), "error": str(e)})
        self.last_checks["completion"] = results
        return results

    def match_tech_tasks(self) -> List[Dict]:
        results = []
        for task in self.tech_tasks:
            try:
                if not task.get('completed'):
                    logger.warning(f"üîß –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –¢–ó: {task['description']}")
                    results.append({"description": task['description'], "status": "not_completed"})
                else:
                    results.append({"description": task['description'], "status": "completed"})
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –¢–ó: {str(e)}")
                results.append({"description": task.get('description', 'unknown'), "error": str(e)})
        self.last_checks["tech_tasks"] = results
        return results

    def generate_full_report(self) -> Dict:
        logger.info("üìã –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á—ë—Ç–∞ –ü–¢–û")
        report = {
            "timestamp": datetime.now().isoformat(),
            "budget": self.check_budget(),
            "schedule": self.check_schedule(),
            "acceptance": self.verify_acceptance(),
            "completion": self.verify_completion(),
            "tech_tasks": self.match_tech_tasks(),
            "validation_errors": self.validation_errors
        }

        critical_issues = (
            report['budget'].get('status') == 'exceeded' or
            any(task.get('status') == 'delayed' for task in report['schedule']) or
            any(act.get('status') == 'not_approved' for act in report['acceptance']) or
            any(act.get('status') != 'accepted' for act in report['completion']) or
            any(task.get('status') == 'not_completed' for task in report['tech_tasks'])
        )

        if critical_issues:
            logger.warning("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –≤ –ø—Ä–æ–µ–∫—Ç–µ")
        else:
            logger.info("‚úÖ –ü—Ä–æ–µ–∫—Ç –≤ –Ω–æ—Ä–º–µ")

        return report

    def save_report(self, report: Dict, filename: str = "pto_report.json"):
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report, f, ensure_ascii=False, indent=4)
            logger.info(f"–û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ —Ñ–∞–π–ª {filename}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –æ—Ç—á—ë—Ç–∞: {str(e)}")

    def get_critical_issues(self) -> List[str]:
        issues = []
        budget = self.last_checks.get('budget', {})
        if budget.get('status') == 'exceeded':
            issues.append("–ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –±—é–¥–∂–µ—Ç–∞")

        for task in self.last_checks.get('schedule', []):
            if task.get('status') == 'delayed':
                issues.append(f"–ó–∞–¥–µ—Ä–∂–∫–∞: {task.get('task')}")

        for act in self.last_checks.get('acceptance', []):
            if act.get('status') == 'not_approved':
                issues.append(f"–ê–∫—Ç –Ω–µ —É—Ç–≤–µ—Ä–∂–¥—ë–Ω: {act.get('stage')}")

        for act in self.last_checks.get('completion', []):
            if act.get('status') != 'accepted':
                issues.append(f"–û–±—ä–µ–∫—Ç –Ω–µ —Å–¥–∞–Ω: {act.get('stage')}")

        for task in self.last_checks.get('tech_tasks', []):
            if task.get('status') == 'not_completed':
                issues.append(f"–ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –¢–ó: {task.get('description')}")

        return issues

    def notify_about_issues(self):
        issues = self.get_critical_issues()
        if issues:
            logger.warning(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã: {